class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        #does it matter the order we search from an initial node
        #my int is no
        #maybe do an initial search where you mark all the nodes affected by each individual initial node
        #maybe by not going through initial nodes?
        #oh wait. by removing frmo initial, we're not removing the actuaal node, just removing it from initial, so it's not getting infected initially
        
        #so yeah. do your search from each node,
        #mark all the nodes with a list of the initial node it was infected by
        #those nodes with only onne initial node marked, are the ones that would lower the M(innitial)
        #any with more than 1 will get infected regardless
        #then just attribute that count to each node and pick the one with the highest
        
        #how to set up our search
        #a dfs passing through normal graph dfs and the initial node
        #infected will be the same as seen (searched on, no need to research)
        
        #or let's do bfs just to practice
        #adj already there for us in graph
        from collections import deque
        n = len(graph)
        markedtoinit = collections.defaultdict(list)
        initscore = collections.defaultdict(int)
        #have our list of nodes each init will mark
        #need a list of nodes each init solely marked
        #first have nodes marked by mapped to innit node that marked it
        #take the ones that only have one in their list
        #add that one to a score for each init
        
        
        def bfs(initial):
            nonlocal n
            nonlocal markedtoinit
            seenmask = 0
            q = deque()
            def markseen(ind):
                nonlocal seenmask
                seenmask ^= 1 << ind
                return
            def getneis(i):
                nonlocal seenmask
                neis = []
                for j in range(n):
                    if j==i:
                        continue
                    if graph[i][j]==1:
                        
                        if seenmask & 1 << j:
                            #print('cont',i,j)
                            continue
                        markseen(j)
                        neis.append(j)
                print(i,neis)
                return neis
            
            markseen(initial)
            q.append(initial)
            while q:
                x = q.popleft()
                neis = getneis(x)
                print(x,neis)
                for nei in neis:
                    q.append(nei)
            seen = set()
            for i in range(n):
                if seenmask & 1 << i:
                    #print(initial,i,'se')
                    seen.add(i)
                    markedtoinit[i].append(initial)
            #print(initial,seen)
        #####end bfs
        for node in initial:
            bfs(node)
        marked = []
        
        
        for nodeind, markedby in markedtoinit.items():
            marked.append((nodeind,markedby))
            if len(markedby)==1:
                initscore[markedby[0]] += 1
       # print(marked,'marked')
        print(marked,'marked')
        scores = []
        for node,score in initscore.items():
            scores.append((-score,node))
        print(scores)
        scores.sort()
        if not scores:
            return sorted(initial)[0]
        return scores[0][1]
        
            
                
            
            
            
            
            
            
            
            
